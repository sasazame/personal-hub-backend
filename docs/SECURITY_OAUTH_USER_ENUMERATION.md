# OAuth ユーザー列挙攻撃の防止

## 背景

OAuth（ソーシャルログイン）を実装する際、以下のセキュリティリスクを考慮する必要があります：

1. **ユーザー列挙攻撃（User Enumeration）**: 攻撃者がメールアドレスの存在を確認できる
2. **認証方法の漏洩**: アカウントがパスワード認証かソーシャル認証かを特定できる

## 実装方針

### 方法1: 情報漏洩を完全に防ぐ（現在の実装）

```java
// すべてのケースで同じエラーメッセージ
throw new UsernameNotFoundException("Invalid email or password");

// OAuthユーザーには絶対にマッチしないダミーパスワードを設定
password = "$2a$10$dummypasswordthatwillnevermatchanyuserinput";
```

**メリット:**
- ユーザーの存在を確認できない
- 認証方法を特定できない
- タイミング攻撃にも強い

**デメリット:**
- OAuthユーザーが誤ってパスワードログインを試みた場合、適切な案内ができない
- UXが低下する可能性がある

### 方法2: UXを優先した実装（代替案）

```java
// OAuthユーザーには明確なメッセージ
if (user.getPassword() == null) {
    throw new UsernameNotFoundException("Please use Google or GitHub to sign in");
}
```

**メリット:**
- ユーザーに適切な案内ができる
- より良いUX

**デメリット:**
- ユーザー列挙攻撃が可能
- 認証方法が漏洩する

## セキュリティとUXのトレードオフ

### 現在の実装の根拠

1. **メールアドレスの公開性**
   - 多くの場合、メールアドレスは準公開情報
   - ソーシャルメディアやビジネスカードで公開されている

2. **OAuth プロバイダーの保護**
   - Google/GitHubは独自の強力なセキュリティ機能を持つ
   - 2要素認証、異常検知、レート制限など

3. **攻撃の実用性**
   - メールアドレスの存在を知っても、OAuth認証を突破するのは困難
   - パスワードリスト攻撃が使えない

## 推奨事項

### 1. 現在の実装を維持（セキュリティ優先）
- 情報漏洩を完全に防ぐ
- エンタープライズや金融系アプリケーションに適している

### 2. 追加のセキュリティ対策
```java
// ログイン試行の記録
securityEventService.recordLoginAttempt(email, ipAddress, success);

// レート制限の強化
// 同一IPからの試行を制限
```

### 3. UIでの補完
- ログイン画面に「ソーシャルログインで登録した方はこちら」のような案内
- パスワードリセット時に適切なメッセージ表示

## 結論

現在の実装（情報漏洩を防ぐ）は、セキュリティのベストプラクティスに従っています。UXの改善は、UI側での工夫で対応することを推奨します。

```javascript
// フロントエンドでの実装例
const LoginForm = () => {
  const [error, setError] = useState('');
  
  const handleLoginError = (error) => {
    // 一般的なエラーメッセージ
    setError('ログインに失敗しました。メールアドレスとパスワードをご確認ください。');
    
    // ヘルプテキストを表示
    showHelpText('ソーシャルログインで登録された方は、下のボタンからログインしてください。');
  };
};
```